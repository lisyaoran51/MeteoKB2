
https://e-mailky.github.io/2016-10-13-linux_irq
https://github.com/s-matyukevich/raspberry-pi-os/blob/master/docs/lesson03/linux/timer.md
https://www.cnblogs.com/arnoldlu/p/7078223.html
https://victoryuembeddedlinux.blogspot.com/2012/03/
https://blog.csdn.net/yinjian1013/article/details/78476072

dt
https://github.com/raspberrypi/linux/issues/1473


fpc 7.5元/條 燈條要過UL認證
燈泡0.25元/顆，20顆5元
端子0.5元/條
smt2元/條

燈條ㄧ條15元 60條900元

燈板200元，共1100元


3/28 
	1. 研究uart2
	http://blog.ittraining.com.tw/2015/05/raspberry-pi-2uart.html   PL2303 USB to UART
	https://hackaday.com/2015/11/28/first-raspberry-pi-zero-hack-piggy-back-wifi/ pp22 pp23 = D+ D-
	https://othermod.com/raspberry-pi-zero-external-usb-connector/
	
	2. 快速關機程序
	1~2秒
	
	3. 差動旋鈕
	
	4. pi sd card
	https://subscription.packtpub.com/book/hardware_and_creative/9781786463852/1/ch01lvl1sec9/understanding-the-standard-connectors-and-test-points
	https://www.technigem.com/2017/01/raspberry-pi-points-de-test/
	
4/7
	pwm clock divider 
	https://www.iot-programmer.com/index.php/books/22-raspberry-pi-and-the-iot-in-c/chapters-raspberry-pi-and-the-iot-in-c/60-raspberry-pi-and-the-iot-in-c-pulse-width-modulation-servos-and-more?start=1
	
	inlude bcm2835.h in kernel mod
	https://www.linuxquestions.org/questions/programming-9/lkm-trouble-with-compile-stdint-h-4175522738/
	
	kernel led pwm
	https://android.googlesource.com/kernel/msm/+/android-msm-3.9-usb-and-mmc-hacks/drivers/leds/leds-pwm.c
	
	driver use bcm2835
	https://github.com/ahmedius2/Simple-PL011-RTDM-driver/blob/master/bcm2835.h
	
	多個文件時不能用同名
	https://blog.csdn.net/zengxianyang/article/details/50710695
	
	workqueue的delay時間不準
	
	要udelay(20)燈光才會穩定
	無法嘗試mono audio
	
4/8
	mono只要改config.txt就好
	放pwm時會有尖銳噪音
	
4/10
	單聲道 http://pi.eggum.net/2013/09/airplay-or-shairport-that-is.html
	
	alsa用pwm 13 func=4
	pwm用channel1(bcm2835lib)(還有問題)
	找到原因：bcm2835_pwm_set_clock(BCM2835_PWM_CLOCK_DIVIDER_16);會把整個PWM都改掉
	
	bcm2835_gpio_fsel(18,BCM2835_GPIO_FSEL_ALT5 ); 這個要開著，完成。
	也不能bcm2835_pwm_set_range
	
	一顆亮20us，可以亮500顆(t=0.01s)，一秒可以刷100次(f=100)
	
	50W
	
4/17
	http://reneeciou.blogspot.com/2013/08/linux-kernel-threads.html
	kthread
	
4/18
	
	/etc/asound.conf
	
	pcm.card0 {
		type hw
		card 0
	}
	ctl.card0 {
		type hw
		card 0
	}
	pcm.monocard {
		slave.pcm card0
		slave.channels 2
		# type plug
		type route
		ttable {
			# Copy both input channels to output channel 0 (Left).
			0.0 1
			1.0 1
			# Send nothing to output channel 1 (Right).
			0.1 0
			1.1 0
		}
	}
	ctl.monocard {
		type hw
		card 0
	}
	pcm.!default monocard

	https://raspberrypi.stackexchange.com/questions/61771/options-of-adding-additional-pwm-channel-to-pi-zero
	
	alsa bcm2835 source
	https://www.raspberrypi.org/forums/viewtopic.php?t=4958
	
	alsa的sourcce code從linux/sound/arm/bcm2835-pcm.c到alsa的pcm.c
	
	改dts
	https://www.raspberrypi.org/forums/viewtopic.php?t=190010
	https://hackaday.io/project/9467-piboy-zero/log/35090-pi-zero-pwm-audio-device-tree-overlay
	
	不用lib
	https://www.raspberrypi.org/forums/viewtopic.php?t=231994
	
	延就pwm，怎麼用reg開
	http://www.scribd.com/doc/127599939/BCM2835-Audio-clocks
	
	
	http://koreav6.co.kr/~suhopark/lxr9/http/source/include/
	
	努力把aplay的channel讀出來
	
	
4/22
	
	struct _snd_pcm {
	char *name;
	snd_pcm_type_t type;
	int stream;
	int mode;
	int poll_fd;
	int setup;
	unsigned int access;		/* access mode */
	unsigned int format;		/* SND_PCM_FORMAT_* */
	unsigned int subformat;		/* subformat */
	unsigned int rate;		/* rate in Hz */
	unsigned int channels;		/* channels */
	size_t fragment_size;		/* fragment size */
	unsigned int fragments;		/* fragments */
	unsigned int start_mode;	/* start mode */
	unsigned int ready_mode;	/* ready detection mode */
	unsigned int xrun_mode;		/* xrun detection mode */
	size_t avail_min;		/* min avail frames for wakeup */
	size_t xfer_min;		/* xfer min size */
	size_t xfer_align;		/* xfer size need to be a multiple */
	unsigned int time: 1;		/* timestamp switch */
	size_t boundary;		/* pointers wrap point */
	unsigned int info;		/* Info for returned setup */
	unsigned int msbits;		/* used most significant bits */
	unsigned int rate_master;	/* Exact rate is rate_master / */
	unsigned int rate_divisor;	/* rate_divisor */
	size_t fifo_size;		/* chip FIFO size in frames */
	size_t buffer_size;
	size_t bits_per_sample;
	size_t bits_per_frame;
	size_t *appl_ptr;
	volatile size_t *hw_ptr;
	int mmap_rw;
	snd_pcm_channel_info_t *mmap_channels;
	snd_pcm_channel_area_t *running_areas;
	snd_pcm_channel_area_t *stopped_areas;
	void *stopped;
	snd_pcm_ops_t *ops;
	snd_pcm_fast_ops_t *fast_ops;
	snd_pcm_t *op_arg;
	snd_pcm_t *fast_op_arg;
	void *private;
};
終於找到

find . -name "*.c" -print0 | xargs -0 -I % sh -c 'echo %; cat %' | grep -e "\./" -e ""



po的ffd是4 對象是pcmC0D0p

4/23
	目前卡再 pcm: snd_pcm_wait_nocheck的poll
	
	blocking io https://www.oreilly.com/library/view/linux-device-drivers/0596000081/ch05s02.html
	https://stackoverflow.com/questions/53351944/how-does-the-scheduler-know-that-a-thread-is-blocked-waiting-for-input
	
	
	
	/sys/devices/platform/soc/soc:audio/bcm2835_alsa/sound/card0/
	
	可能再 snd_pcm_playback_poll pcm_native.c
	
	是snd_pcm_do_drain_init直接把runtime->status->state改draining
	
	是snd_pcm_action_single叫這個功能
	就算是可以播的狀況，snd_pcm_do_drain_init還是會發生
	
	hw_ready的控制是在gpu裡處理的，處理完後GPU匯回傳VC_AUDIO_MSG_TYPE_COMPLETE，就可以拿出收回的buffer，把他減回hw_ready裡
	
	
	TLC59116 1mhz_i2c 97khz with 256 step 
PCA9745 spi       31.25khz with 256 step
pca9634 1mhz_i2c 97khz with 256 step

ltc6992

4/25
	改channels也沒用
	
	wait queue 延遲600us，hrtimer經準度2ms 還是會依直閃
	
	16排，ㄧ排90us的亮度ok
	
	
5/2
	openal 安裝
	apt-get install m4 libalut-dev
	
	apt-get remove alsa-utils
	apt-get install alsa-utils
	
5/6
	core_cm0.h在C:\Users\TsaiJiaYu\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include
	加到include path
	https://blog.csdn.net/Richard4234/article/details/79892357
	
	gcc latency.c -o latency -lsoundio -I../src/ -I../build -lm
	
	找bass
	
5/7
	gcc test1.c -o test1 -lbass
	
	
	Also you can use the LD_LIBRARY_PATH environment variable to tell the linker where to look for this library as well.

I like to leave /usr/lib alone for libraries controlled by a package. 
My own compiled libraries will go in /usr/local/lib. 
But if I want to bundle everything up in, say, /opt/myapp, 
I'll make a wrapper script that sets the LD_LIBRARY_PATH and then keep my library with my executable. 
This is what many programs like firefox, libreoffice, and virtualbox do.

	
	nm -D -C -g 列出so裡面的函試
	http://www.alsprogrammingresource.com/sound_tutorial.html
	
	
	g++ sound.cpp -o sound.o -lbass
	g++ -c vector.cpp
	
	sound.o vector.o testmain.cpp -o testmain -lbass
	
	https://gist.github.com/dlivingstone/1333413
	
5/13
	MCU PWM的code在PWM_try裡，是用反像的接PWM，duty越大亮度越小，0~3ch是PWMA，4~7ch是PWMB
	不知道為什麼 還是會閃
	
5/16
	game host: 裡面擺了很多thread去跑整個遊戲
	
	thread擺哪：
	Program.main -> host = Host.GetSuitableHost(@"osu", true)
	host.Run(new OsuGameDesktop(args)) -> GameHost.Run -> GameHost.bootstrapSceneGraph -> Game.SetHost(this)
	
	遊戲畫面從哪開始：
	OsuGame.LoadComplete -> screenStack = new Loader() -> LoadComponentAsync(new Intro(), d => Push(d)); -> 
	OsuGame.LoadComplete -> intro?.ChildScreen?.MakeCurrent(); -> Intro.OnEntering -> LoadComponentAsync(mainMenu = new MainMenu()) -> preloadSongSelect
	
	PlaySongSelect.preloadSongSelect ->  new PlayerLoader -> 載遊戲
	mainMenu附則把聲音和背景弄出來
	
	-----------
	(拿wifi位置)
	"/sbin/ifconfig | /usr/bin/awk '/HWaddr/ {printf $5}' > %s" 
	
	刪掉
	killall brcm_patchram_plus
	killall bluetoothd
	
	建立連線
	"/usr/sbin/brcm_patchram_plus  --enable_hci --baudrate 1500000 --use_baudrate_for_download --patchram /lib/firmware/broadcom/ap6212a/BCM43438A1.hcd --no2bytes --enable_lpm /dev/ttyS1 --bd_addr `/bin/cat /tmp/bluetooth/bt_mac.txt`"
	
	看藍芽有沒有建起來
	cat /sys/class/bluetooth/hci0/address
	
	看有沒有獨到藍芽資訊
	/usr/bin/hciconfig -a
	
	建立rfcomm
	/sbin/modprobe rfcomm
	
	打開藍芽
	hciconfig hci0 up
	
	開廣播
	hciconfig hci0 leadv
	
	開一個thread不停丟bluez通知，當heart beat
	pthread_create -> bt_gatt_server_send_notification
	
	開一個listen的thread
	pthread_create -> init_listeningTask
{
	會拿到一個socket
	device_handle = hci_open_dev(0)
	
	建立藍芽設定
	le_set_advertising_parameters_cp adv_params_cp;
	
	建立藍芽request
	struct hci_request rq;
	
	資料送出去
	hci_send_req(device_handle, &rq, 1000);
	
	建立藍芽enable指令
	le_set_advertise_enable_cp advertise_cp;
	
	把Request放入指令
	rq.cparam = &advertise_cp;
	
	把enable丟出去
	hci_send_req(device_handle, &rq, 1000);
	
	建立scan response指令，並把自定的uuid放入data_cp.data裡(uuid是指整個furbo的服務id，只有一個)
	le_set_scan_response_data_cp data_cp;
	
	把指令放進request裡
	rq.cparam = &data_cp;
	
	把data丟出去
	hci_send_req(device_handle, &rq, 1000)
	
	設定廣播資料，把mac address擺進去、tx power、vendor specific設定、裝置名稱
	le_set_advertising_data_cp adv_data_cp;
	
	放入request中
	rq.cparam = &adv_data_cp;
	
	把資料丟出去
	hci_send_req(device_handle, &rq, 1000);
	
	設裝置名稱成name和mac
	"/usr/bin/hciconfig hci name '%s %s'"
	
	打開socket收資料
	g_sockfd = socket(AF_BLUETOOTH, SOCK_SEQPACKET,BTPROTO_L2CAP)
	
	把loc_addr設定藍芽種類，擺入socket中
	bind(g_sockfd,(struct sockaddr *)&loc_addr,sizeof(loc_addr))
	
	設定資安
	setsockopt(g_sockfd, SOL_BLUETOOTH, BT_SECURITY, &btsec, sizeof(btsec))
	
	等待藍芽回傳
	listen(g_sockfd,10)
	
	設定要等待的動作read和write
	 FD_SET(g_sockfd,&readfd); FD_SET(g_sockfd,&writefd);
	
	開始等待藍芽裝置
	select(max_fd + 1, &readfd, &writefd, NULL, &wait_time);
	
	檢查是否可讀取
	 FD_ISSET(g_sockfd,&readfd)
	 
	接下這個socket
	accept(g_sockfd,(struct sockaddr *)&rem_addr,&sin_size ))
	
	打開廳續習的loop
	mainloop_init();
	
	跑聽訊息的loop
	mainloop_run();
}
	
	把server加入socket fd、queue
	server = new0(struct server, 1);
	server->gatt = bt_gatt_server_new(server->db, att, mtu);
	
	populate gap和gatt(把Callback放進去)
	populate_gap_service
	populate_gatt_service
	populate_furbo_service
	
	跑loop(比btgatt_server.c少做一次mainloop_add_fd)
	mainloop_run();
	
	離開
	server_destroy
	
5/19
	gatt
	https://learn.adafruit.com/introduction-to-bluetooth-low-energy?view=all
	https://yq.aliyun.com/articles/312023
	
5/20
	http://dev.ti.com/tirex/content/simplelink_cc2640r2_sdk_1_40_00_45/docs/blestack/ble_user_guide/html/ble-stack-3.x/gatt.html
	
	安裝bluz
	https://www.e-learn.cn/content/wangluowenzhang/1510657
	
	打開btgatt-server
	
	sudo tools/btmgmt -i hci0 power off
sudo tools/btmgmt -i hci0 le on
sudo tools/btmgmt -i hci0 connectable on
sudo tools/btmgmt -i hci0 name "some friendly name"
sudo tools/btmgmt -i hci0 advertising on
sudo tools/btmgmt -i hci0 power on
tools/btgatt-server -i hci0 -s low -t public -r -v

	
	attr handle: 0x0001, end grp handle: 0x0006 uuid: 00001800-0000-1000-8000-00805f9b34fb //generic access
	attr handle: 0x0007, end grp handle: 0x000a uuid: 00001801-0000-1000-8000-00805f9b34fb //generic attribute
	attr handle: 0x000b, end grp handle: 0x0012 uuid: 0000180d-0000-1000-8000-00805f9b34fb //heart rate
	
	handle: 0x0002, char properties: 0x02, char value handle: 0x0003, uuid: 00002a00-0000-1000-8000-00805f9b34fb //Device Name
	handle: 0x0005, char properties: 0x02, char value handle: 0x0006, uuid: 00002a01-0000-1000-8000-00805f9b34fb //Appearance
	handle: 0x0008, char properties: 0x22, char value handle: 0x0009, uuid: 00002a05-0000-1000-8000-00805f9b34fb //Service Changed
	handle: 0x000c, char properties: 0x10, char value handle: 0x000d, uuid: 00002a37-0000-1000-8000-00805f9b34fb //heart rate measurement
	handle: 0x000f, char properties: 0x02, char value handle: 0x0010, uuid: 00002a38-0000-1000-8000-00805f9b34fb //body sensor location
	handle: 0x0011, char properties: 0x08, char value handle: 0x0012, uuid: 00002a39-0000-1000-8000-00805f9b34fb //heart rate control point
	
	>>char-desc
	handle: 0x0001, uuid: 00002800-0000-1000-8000-00805f9b34fb
	handle: 0x0002, uuid: 00002803-0000-1000-8000-00805f9b34fb
	handle: 0x0003, uuid: 00002a00-0000-1000-8000-00805f9b34fb
	handle: 0x0004, uuid: 00002900-0000-1000-8000-00805f9b34fb
	handle: 0x0005, uuid: 00002803-0000-1000-8000-00805f9b34fb
	handle: 0x0006, uuid: 00002a01-0000-1000-8000-00805f9b34fb
	handle: 0x0007, uuid: 00002800-0000-1000-8000-00805f9b34fb
	handle: 0x0008, uuid: 00002803-0000-1000-8000-00805f9b34fb
	handle: 0x0009, uuid: 00002a05-0000-1000-8000-00805f9b34fb
	handle: 0x000a, uuid: 00002902-0000-1000-8000-00805f9b34fb
	handle: 0x000b, uuid: 00002800-0000-1000-8000-00805f9b34fb
	handle: 0x000c, uuid: 00002803-0000-1000-8000-00805f9b34fb
	handle: 0x000d, uuid: 00002a37-0000-1000-8000-00805f9b34fb
	handle: 0x000e, uuid: 00002902-0000-1000-8000-00805f9b34fb //這個控制heart rate
	handle: 0x000f, uuid: 00002803-0000-1000-8000-00805f9b34fb
	handle: 0x0010, uuid: 00002a38-0000-1000-8000-00805f9b34fb
	handle: 0x0011, uuid: 00002803-0000-1000-8000-00805f9b34fb
	handle: 0x0012, uuid: 00002a39-0000-1000-8000-00805f9b34fb
	
	>>char-write-req 0x0e 0x0100
	
	
	http://lihgong.blogspot.com/2014/10/blog-post.html
	
	在populate_hr_service裡面的add characteristic其中一個是write callback，當寫入發生後會定時執行
	bt_gatt_server_send_notification，把心跳資料送出去。
	
	
	obex
	http://sgerwk.altervista.org/bluetooth/linux.html
	
	sdp
	https://stackoverflow.com/questions/53069598/bluez-adding-services-attributes-and-profiles-without-sdptool-command
	
5/21
	bind sdp to channel
	http://blog.float.tw/2013/01/linux-connect-bluetooth-device-with-spp.html
	
	pi0w uart用法
	
	enable_uart=1
	dtoverlay=pi3-disable-bt
	sudo systemctl disable hciuart
	core_freq=250
	(部要改cmdline.txt)
	
	
5/25
	https://blog.csdn.net/onetwothreef/article/details/49835971
	
	https://github.com/nagimov/adxl345spi
	gcc -Wall -pthread -o adxl345spi adxl345spi.c -lpigpio -lrt
	
6/3 
	看起來燈光板只要一點點電流就會很亮
	一顆亮，其他顆會被影響到，一起亮

	打開bluetooth scan方法：
	ctl = socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI)
	cmd_scan(ctl, di.dev_id, *argv)
	
	dr.dev_opt = SCAN_PAGE | SCAN_INQUIRY;
	ioctl(ctl, HCISETSCAN, (unsigned long) &dr)
	
	https://www.cnblogs.com/chenbin7/archive/2012/10/16/2726515.html
	
	ew7811un要加上8192cu.conf 材不匯段電 再modprobe.d裡
	# Disable power management
	options 8192cu rtw_power_mgnt=0 rtw_enusbss=0

	
6/4
	藍芽傳檔
	http://www.postuni.si/postuni/clanki/articles/serialports/serialports.htm
	
	藍芽較材
	http://people.csail.mit.edu/rudolph/Teaching/Articles/BTBook.pdf
	
6/5
	usb藍芽開啟
	
6/11
	重寫framework，
	elapse改update，經過的時間記在block裡面。
	用input manager當root，每次更新時把所有輸入送給所有子物件
	再main interface收集所有輸入，類似openTK window，由input handler去抓這些輸入，然後回傳給input manager
	
	update是用root去抓所有子物件，呼叫他們的update
	
	要把hierachal那些移到framework/allocation裡
	
	程式應該設計為三個部分：1. 藍芽更新程式 2. 鋼琴程式 3. 遊戲程式
	
	input state主要是用來delegate給註冊的handle函式
	
	只用game thread 其他thread部件新class
	
	
	drawable只要加入，就會去抓parent的clock
	
	但是整個root用的clock不是thread裡的Clock，是bootstrapSceneGraph()時設定的SceneGraphClock，SceneGraphClock就是update thread的clock
	所以root的clock是要手動設定的
	
	drawthread應該用部到clock
	
	thread sleep會花54000ns，在game thread的run work的結尾睡。
	
	因為input是由遊戲主動抓，所以還是要用inputthread
	
	
	暫停應該是讓遊戲暫停，但不影響鋼琴音
	暫停時會把播訪的音樂的clock暫停
	
	為什麼player的clock能夠與外面的clock連杰？還是不行？
	
	player應該是用offset clock，擺一個child，把child的clock換成offset clock，然後把ruleset container擺到這個child的child
	
	osu本身沒有暫停鍵，暫停就要縮小視窗，所以沒有人會去控制pause container，而是pause container自己去詢問host是否active，如果
	視窗縮小才會pause
	
	控制的方法應該是 再playfield load的時候，把Event processor的algorithm add child，讓這個algorithm有pause container的資料
	然後在playfield add event processor的時候，再把algorithm擺入這些processor裡。
	
	不知道即時的event要怎麼add進playfield裡？
	
6/13
	藍芽目前只要做到可以互連就好，不用下載檔案或升級成是
	
	遊戲一開始是先把intro去load game，再到main menu，按下solo後會到songselect
	
	目前我的寫法是在session裡面擺選好的遊戲規則和歌曲
	
	要看一下選擇時song select怎麼抓到歌曲和規則
	
	
	遊戲規則是在player load的時候去抓game的Beatmap，然後把Beatmap的規則拿出來
	
	beatmap的修改是在song select的carouselSelectionChanged裡面，
	
	
6/14
	選擇歌曲時，會再xong select的carouselSelectionChanged裡面把整個osu screen內的Beatmap給換成選擇的那個beat map(在performLoad裡)
	然後會再UpdateBeatmap裡面把目前PlaySongSelect裡的modSelect綁上這一個beatmap。
	
	最後遊戲要開始時，再把mod檢查一次，檢查完就開始遊戲，推入player
	
	
	應該要建bindable和action list，resource store也要開始寫
	(mod應該是一個beatmap檔都支援，同一個beatmap檔可以選擇很多種mod)
	
	resource store會把路靜下所有檔案，根據抓的附檔名，做成一個list
	當需要一個檔案的時候，可以用get來把這個檔案的內容抓出來
	
	
	寫trigger中
	
	
6/24
	https://stackoverflow.com/questions/18380820/how-to-combine-stdbind-variadic-templates-and-perfect-forwarding
	把變動參數加入bind
	
	抓到function的argument數量
	https://stackoverflow.com/questions/9044866/how-to-get-the-number-of-arguments-of-stdfunction
	
	action list 寫完了，就照functional test的寫法
	呼叫的時候必須先bind好，然後把名字打進去
	
	bindable好了，resource store好了
	
	把intro -> songselect -> player loader都建好，繼承scene
	
	Scene應該擺在Framework裡
	
	把clock大概見好
	
6/25
	
	input manager裡面會有update不停更新狀態，裡面用handle new state -> updateKeyboardEvents -> handleKeyDown -> PropagateKeyDown
	
	放著案件資料的式 update裡面的pendingStates，由GetPendingStates獲得，用createDistinctInputStates整理，
	
	GetPendingStates去向所有input manager裡面的InputHandlers抓他們的資料，h.GetPendingStates();
	
	input handler是來自host的AvailableInputHandlers，這些handler是在遊戲開始前，在run或是setup config時把openTK的handler擺進去
	
	在handler裡面，會先把host.Window.KeyDown += handleState;，註冊好以後，根據handle state的做法，來抓取資料
	
	所以按下的來源不是來自主程式，而是來自window。
	
	window是怎麼呼叫key事件呢？ polling還是中斷？應該是在另一個thread做polling
	
	應該是向input thread拿資料，但是thread是每個frame結束後就不儲存任何資料，input thread只能再拿到資料的時候發通知給其他人
	
	簡單做法是用message queue，input thread把案件丟進去，input hanler在get state的時候再讀出來
	
	但是osu是每當案件進來，就值接呼叫input handler把案件收進去。最後get state時再把案件從pending state裡拿出來
	
	問題是input thread要怎麼呼叫handler？
	
	說不定input thread本來就有全線去叫handler的handle來處理，就可以把資料塞到pending state
	
	
	再drawable的load裡，有把clock給從cache抓出來擺進去
	再drawable的set parent裡，有把parent的clock丟進去
	
	再player加入pause container時，會把他的child的clock換成pause container用的framed clock，讓pause container可以控制下面的時間
	最後把ruleset conatiner設成這個child的child
	
	
	把updatable改好了
	
	讀取輸入的做法是，在host裡面嘉一個onInput，如果有新輸入在input thread抓到，就直接叫on input，把輸入全都丟出去
	
	
6/26
	
	input manager會在每次handle new state時，用updateInputQueues把所有的child都擺入input queue裡
	
	因為是從parent掃到child，所以最後要把queue反過來，就會變成從child到parent
	
	在handle new state時，呼叫propagate key down，只會叫最底端的child，並對這個child做trigger key down
	
	drawable被trigger key down以後，就會呼叫on key down的所有工作
	
	有個問題是，這條tree只能單條，多條的話就會抓不到最下層的child
	
	另外，如果要讓鋼琴永遠都按下去會有聲音，就要寫一個queue獨立於input queue，專門給鋼琴用
	
	
	發現有個scheduler，是再每個container裡面都有，會在update sub tree的時候，去執行udate檢查有沒有排定事項要執行
	
	
	InterpolatingFramedClock是用stopwatch clock當源來做的
	stopwatch clock是把系統的stopwatch拿來用，stopwatch是從Start開始計時的碼表，經過的時間擺在ElapsedTicks裡面，這個經過的時間會在乘上一個rate
	表示時間經過的速度，最後才是整個current time。stopwatch clock的計時是從new的時候就開始計時
	如果framed clock把stopwatch clock當源的話，就會用stopwatch的時間當時間
	InterpolatingFramedClock是不用他的源來看時間，另外拿一個stopwatch來看時間，要抓時間的時候就從stopwatch去抓經過多久，再擺進來。功能是稍微減少frame和現在時間的時間差
	
	seek是重要的功能，可以把剛開始計時的Stopwatch直接設成現在時間
	DecoupleableInterpolatingFramedClock是再他的source停了以後，還可以繼續跑的clock，可能是為了如果音樂是他的source，音樂播完以後遊戲就會停掉，所以要繼續跑
	音樂的clock會在pause container裡面被停掉，但是這樣的話DecoupleableInterpolatingFramedClock就會繼續跑，這樣不隊
	
	DecoupleableInterpolatingFramedClock檢查source有沒有停，是看Source的is running，當音樂停止的時候，track會把is rinning改成false
	DecoupleableInterpolatingFramedClock就會發現，然後去跑另一個decoupled clock
	
	看起來是pause container再pause時，會把FramedOffsetClock的process source clock關掉，所以他的source:"DecoupleableInterpolatingFramedClock"就不會跑
	所以FramedOffsetClock再跑的時候，拿到的時間都是已經停住的時間，child們也就都拿不到新的時間。
	
6/28
	之後clock計得要寫解構子
	
	change source時會把多的source clock給memory leak
	
	clock寫完了 hierachal寫完了
	
	intro轉場要寫，要找出來osu是怎麼push轉場的，是draw frame找draw root來一個一個畫，draw root是由children轉換成draw node再串起來擺入buffer
	我們的畫面不用那麼多塗層，應該就不用時做這個功能了
	另外要不要重寫一個dependency container取代cachable'
	
6/29
	看不懂，轉廠自己映寫，不要看osu
	
	在有圖片的東西裡面，計成drawable，用draw thread去每個child抓drawable，拿map來複製
	
7/2
	要把playfield改成用drawable來畫圖，然後scheduler要看看要步要重寫
	scheduler應該步需要再用了，因為要改成可以調整歌曲進度，鎖以event要直接丟到master裡面，步用給scheduler排順序
	
	drawframe寫了，步太知道要寫什麼
	playfield裡面要改很多，scheduler拿掉，event process master要分interval組別，effect mapper應該是在draw frame才畫圖，步是在update frame畫圖
	
	準備寫main interface，已經改好mapper那些了
	
7/4
	寫好time controller了，但是decoupled clock裡面應該還有問題，還沒去改
	
	下次應該要來把input那段寫完
	
7/5
	寫到input manager一半，接下來要寫藍芽input
	
7/8 
	藍芽沒什麼好寫的，來寫input thread，要先把main interface寫完
	
7/10
	main interface插一些沒寫完
	不改dependenct container的話，架構一直背影響，現在main interface就沒辦法去拿裝置
	
7/14
	在host的bootstrapSceneGraph裡面有root.Load(SceneGraphClock, Dependencies);，會把在host裡面的Dependencies擺進去
	把cachable改成用Dependencies了，遊戲開始的時候要自己把clock和dependencies擺進去，然後async來讀取內容
	
	問題是到時候要刪掉child實，要怎麼把cache拿出來
	osu在remove的時候會把child拿掉，但是不會去動dependencies
	不對，他是完全不會自動去cache東西，只有主動去呼叫cache實才會把資源放進去，child只是用來抓parent的dependencies，parent和child通通不會出現在cache裡
	
7/15
	不知道還要寫什麼，先來寫handle key down，寫到一半
	
	
7/16
	on key down基本寫好，上面的要在自己寫反應
	
7/17
	現在要寫game，要搞清楚game試用來幹嘛的
	看起癌game只是用來擺音樂和資源的，像是字體、shader、圖片
	game裡面的audio manager和resource要補完
	
7/21
	繼續看audio manager
	如果audio component不用update的話，其實也沒有用
	
	track可以seek sample不能seek
	
7/22
	game的load是在game host的bootstrapSceneGraph時，會把game加到root的child，嘉進去的時候就會load
	load的時候才會去抓dependency，是drawable負責抓，鎖已到game的時候就已經抓到game host的dependency了
	
7/23
	他所有resource store都加入Resources進去，是因為在resources裡面加了一個DllResourceStore(MainResourceFile)，這個store負責把程式路徑抓出來，讓所有resource store都可以抓到程式路靜下的東西
	
	看intro要怎麼開始
	他好像是直接load loader的clock和dependencies，但是不會變成他的child
	
	從intro到menu到songselect到playerloader到player，通通沒有add child，是用load component，player之後才有child
	
	錯了，是每個screen都有一個child叫座childModeContainer，在push的時候會把childModeContainer給add child，所以會變成childModeContainer的child
	
	我應該設計成 push時就把screen給變成child
	play song select時會直接把player給push到child，跳過player loader
	感覺可以直接跳過player loader，因為那個試過場而已
	
7/24
	寫scene發現要座delay scheduler比較好寫
	寫scheduler到一半
	
7/25
	scheduler寫完，回去寫intro
	
7/26
	test.c還沒compile好
	
7/29
	g++ main.o ../tlc5940-raspberry/gpio.o ../tlc5940-raspberry/raspberry-gpio.o ../tlc5940-raspberry/wiringPi.o -I../tlc5940-raspberry -Ipthread -o test

g++ main.o ../tlc5940-raspberry/gpio.o ../tlc5940-raspberry/raspberry-gpio.o ../tlc5940-raspberry/wiringPi.o ../tlc5940-raspberry/softPwm.o ../tlc5940-raspberry/softTone.o -I../tlc5940-raspberry -Ipthread -o test

g++ main.o ../tlc5940-raspberry/gpio.o ../tlc5940-raspberry/raspberry-gpio.o ../tlc5940-raspberry/wiringPi.o ../tlc5940-raspberry/softPwm.o ../tlc5940-raspberry/softTone.o ../tlc5940-raspberry/piHiPri.o -I../tlc5940-raspberry -pthread -o test

 g++ main.cpp -c -I../

 https://web.archive.org/web/20150824204120if_/https://tlc5940arduino.googlecode.com/svn/wiki/images/breadboard-arduino-tlc5940.png
 https://playground.arduino.cc/Learning/TLC5940/
 這樣接會動
 
7/30
	vprg要high，步然資料會被洗掉
	
7/31
	gpclk用法
	https://github.com/Guzunty/Pi/blob/master/src/gzlib/src/gz_clk.c
	http://abyz.me.uk/rpi/pigpio/examples.html#Misc_code
	gpclk無法操控，改天再實驗
	
8/1
	從intro到player寫好了
	之後可以來寫藍芽那段，還不知道怎麼寫
	
8/9
	debounce
	https://www.allaboutcircuits.com/technical-articles/switch-bounce-how-to-deal-with-it/
	
8/21
	回來把播放音樂寫完
	
8/22
	寫到bass sample channel
	
	Action應該改成map和vector兩種
	
	把host到intro串起來了，接下來剩一大堆之前懶得寫完的細節，但是架構應該都好了
	
8/23
	把錯誤解一解，audio manager的樣板要改
	
8/24
	EventProcessorMaster好像也要大改
	
8/25
	現在不用renderer，而是由drawthread去抓每一個物件，然後畫到圖上，所以所有map algo和playfield都要改
	
	時間改存在clock裡，所以所有Event都要改
	
8/28
	template必須寫在header裡，不能寫在cpp裡，所以action改成只有.h
	
	原本規則都是擺在session裡，以後要改成從別的地方拿，向player等
	

8/29
	規則和譜改由meteo scene每次都從cache裡面抓game的規則和譜，然後bind起來
	
	應該是每一個schedulable全部都有clock，clock匯在load的時候從cache裡面抓到，也可以在其他時間用Set Clock來更改他的clock成custom clock
	整個遊戲最原始的clock是update thread的clock，匯在host裡面把root給load進去這個clock，下面所有child就都會拿到這個clock
	
	我們的clock擺在updateable裡
	
	寫到要怎麼把event processor擺到period map裡面
	
8/30
	把processor master的update寫好，會把dynamic event自動刪除
	
	只有player是scene，下面都是container
	
	ruleset executor:load -> ruleset executor:playfield load -> playfield:add -> event processor master:add
	在event processor master:add的時候，就會把event processor加入period map裡
	
	畫圖是統一由host的draw去event processor master那get graph
	
	
	audio manager和resource store怎麼去處理音樂，還要寫
	
	input的處理有兩條線，一條是update thread，一條是input thread
	
	update thread的程序是：
	host:update -> input manager:get pending state(跟input handler拿) -> input manager:handle new state -> input manager:update trigger queue(更新一下目前是哪個畫面來接收輸入)
	-> input manager:update Events(叫queue裡面每個container出來抓輸入) -> container:On Key Down(container收到輸入的反應)
	
	input thread的程序是:
	host:input frame -> device:scan input -> peripheral:Trigger On Input -> Panel:On button down -> Panel Input Handler:Handle State -> 將state存入pending states中
	
	還需要把device在register的時候跟peripheral配對，trigger on input那段也還沒寫
	
	update trigger queue還要改寫成只抓到需要輸入的畫面
	
	
9/1
	哪個畫面用來輸入，這個要去看osu的code在決定
	
	input handler是什麼時候initialize? 在host的resetInputHandlers裡面
	
	
9/15
	想不起來之前寫到哪，timecontroller可能需要仔細看
	
	另外要把每一個device寫好，要確定哪一個scene抓到輸入，再看看osu怎麼寫，或是直接用make current解決
	
9/16
	public bool IsCurrentScreen => !hasExited && ChildScreen == null; 這個只是scene用來判斷用的，步是輸入用來判斷用的
	
	mouseDownInputQueue.Where(target => target.IsAlive && target.IsPresent)
	
	IsPresent -> 全透明或被縮到最小，舊部是present
	
	所以他是全部child通通都trigger，除了步alive和步是present
	
	現在變成每一個物件只要是Triggerable，舊要在建立時設定自己為isTriggerable，然後調整他可步可用的方式是isValidForTrigger
	
	update queue時會檢查他是步是isTriggerable，輸入時會檢查他是步是valid for trigger
	
	要找一下osu是在哪裡收到按鍵輸入，然後擊破object
	
	DrawableNote.OnPressed -> DrawableHitObject.UpdateJudgement -> DrawableNote.CheckForJudgements -> DrawableHitObject.AddJudgement
	-> DrawableHitObject.OnJudgement.Invoke -> ManiaPlayfield.OnJudgement -> column.OnJudgement -> explosionContainer.Add(new HitExplosion)
																		|--> ScoreProcessor.AddJudgement -> ScoreProcessor.OnNewJudgement
	-> ManiaPlayfield.judgements.Add(new DrawableManiaJudgement)
	
	
	CheckForJudgements會檢查是否超出miss時間，媒超出的話舊建立ManiaJudgement，把得分輸入盡去檢查是perfect還是good，最後在AddJudgement
	在AddJudgement裡面會檢查他的時間差多少，建立judgement時只會檢查他是perfect還是good，這個時候才會真的輸入時間差
	
	ScoreProcessor在OnNewJudgement的時候會去計算分數，計算方式有點複雜
	
	最後才會在ManiaPlayfield用DrawableManiaJudgement來顯示得到miss函是good
	
	在playfield裡面有個child是HitObjectContainer，rulesetContainer.loadObjects會把DrawableHitObject加到這個container裡面當child，
	所以在input的時候每一個object的onpressed才會被呼叫，檢查的時候會把所有idle狀態的object都檢查一次，感覺比較耗效能。
	不知道他怎麼知道這一個和上一個object哪個先被judge，下一個就不用judge
	
	userTriggered是用來判斷有沒有漏接，每次update都會judge一次
	
	我們應該可以直接在processor master裡面針對目前進行的object檢查舊好，步用全都檢查
	
	
	DrawableNote的OnPressed是定義在IKeyBindingHandler裡面，由KeyBindingInputManager來觸發，觸發時會跟具樣板T來給予輸入，例如這邊的輸入是ManiaAction，
	室特別給mania定義的
	
	keyBinding在切換不同遊戲模式時很好用，但是目前我們只有一種輸入模式，效果步大，但是在提高八度/降低八度時用的到，所以還是要用
	
	
	準備把keybinding input manager和 ruleset input manager放盡去，最後再用meteor input manager繼承舊可以了
	
9/18
	root本身試一個input manager，但是因為每個遊戲規則都有配合的input manager，所以在ruleset下面還會有一個ruleset input manageR，在他下面才是playfield
	
	每個遊戲規則的input manger在遊戲時沒有座用，只有在重播的時候才會動。平常還是靠主要的input manager
	
	寫到userinputmanager
	
9/19
	還是要用ruleset input manager才能控制ruleset meteor的物鍵，因為key binding input manager會把不屬於這個規則的物件擋掉，不讓他拿到輸入
	想要拿到輸入的物件，就必須要記成key binding handler<T>，然後把這個規則下的輸入表擺入T，key binding input manager材匯去抓這個物件
	然後把輸入丟給他
	
	寫到PassThroughInputManager::getPendingState
	
9/22
	input key 對硬到 key binding是在rulset的GetDefaultKeyBindings做的，把每個鍵一個一個對過去
	
9/30
	74595，因為github帳密改了，要用
	git -c diff.mnemonicprefix=false -c core.quotepath=false push -v --tags origin master:master
	來push，
	
10/3
	先重新看懂input manager是怎麼跑的，看完再全部檢查完，再去寫其他東西。看完可以去寫device的東西
	
10/7
	load async只是用來同步的add child，他的功能跟addchild沒兩樣，只是在背景值形而已，所以把load async刪掉了
	把static trigger queue拿掉
	把keybinding input manager補完
	
10/8
	ruleset input manager在ruleset container和playfield中間
	
	把can receive input拆成三個因素: inputable , available, is present，所以要精確控制每個東西的這三個要素，input mannager才能運作
	
	osu的做法是把下面每個child都去trigger key down一遍，所有都執行完以後檢查一下有沒有trigger成工
	
	再ruleset container以上的才能接收on key down，如果再ruleset container以下的物件可以接收on key down，就會重覆接收兩次，因為ruleset input manager會再重複丟一次trigger
	所以在ruleset input manager以下只能用on key down(action)
	
	正在寫piano的key binding和sound binding
	
10/9
	把piano大概寫一寫，電腦控制踏板、踏板切掉聲音，全都大概寫一下
	
10/15
	把instrument的樣板分開寫
	
	來寫main interface
	
	再osu是由一個openTK window的一個thread不停的抓輸入，input handler只要住測上去，就會自動收到輸入了
	
	但是我們沒有，我們相對於openTK window的，應該是keyboard device、bluetooth device、display device
	host要拿到這三個device的方法，就是去main interface找已經註冊上去的device，然後在input thread(應該改名叫IO thread)更新的時候去不停的抓資料
	另外input handler也是註冊到peripheral上，更新的時候device會去叫peripheral，再傳送到input handler上
	
	把mian interface搞得差不多，目前需要把host裡面每一個thread的實際跑法寫完
	input handler也要寫，然後要接上去main interface
	MeteoDevice系列要擺到device去，等到確定device怎麼寫以後再寫
	
	game thread還沒寫
	
	還要寫有哪些scene可以接input，哪些scene不行
	哪些scene可以Draw，哪些scene不行
	
	inputable: scene, PassThroughInputManager, event processor master, 
	
	score processor完全沒寫，直接放棄(11越來不及)
	
10/17
	mutex也要寫
	
	寫is present
	
	暫停以後，time controller下面應該全都不能接input
	time controller需要跟input key做binding一下，才知道哪個是pause
	time controller的on button全部都要再修過，現在先寫個大概
	
	timr controller的鍵立和key binding寫好了，但是裡面的時鐘還沒有搞很清楚，應該要把整個遊戲的時鐘通通順一遍
	
	要寫畫面移動
	
	linux file system還沒寫(ResourceStore::initializeFileSystemInterface)
	
10/18
	stopwatch ok
	ThrottledFramedClock ok
	framedClock ok
	InterpolatingFramedClock 建構時根本沒有在使用，因為建構子沒有給他source，在沒有source的時候這個clock完全不會給current time
	
	
	DecoupledInterpolatingFramedClock 的process frame還沒寫，這個看懂要花時間
	
	#include <stdexcept>
	 throw runtime_error("int FramedClock::setCurrentTime() : error. source clock is not adjustable.");
	
10/21
	InterpolatingFramedClock 建構時根本沒有在使用，因為建構子沒有給他source，在沒有source的時候這個clock完全不會給current time
	建構完以後，decoupled clock會去change source，這實inperpolated clock才會拿到framed source，然後可以開始current time
	我們丟進去的clock是audio track，是不能adjust的，丟進去以後interpolated clock會再把他轉成framed clock
	InterpolatingFramedClock的change source從頭到尾沒用到
	
	stop watch在一get current time的時候就start是不對的，應該先start再get current time，但是其他clock都沒有start功能，所以應該在其他clock第一次
	frame的時候把last current time校正一次？所以frame clock會在第一次frame的時候歸零一次
	clock frame的額實start要檢查
	
	InterpolatingFramedClock ok
	DecoupledInterpolatingFramedClock ok
	offsetFramedClock ok
	我們跟osu的差別是可以調整速度和暫停
	
	現在來看rime conttroller
	time controller寫錯了，裡面是自己處理bw ff，但是應該要給speed adjuster處理
	
10/22
	終於找到offset clock再哪跑了，osu的drawable會在每次更新時process custom clock
	
	time controller先用預設跳5秒終，時間調整都讓speed adjuster來作
	
	發現executor和playfield很多width height那些設定沒有改好，接下來應該要來處理map、draw那些問題
	
	draw大概沒問題，要看怎麼平移
	
10/23
	有用到start pitch的地方有兩個: pattern generator和map algo
	再meteor playfiled的load裡會把map algo給add child，
	(為什麼現在map algo不用register buffer map?)已經改成要buffer map
	目前在改meteor playfield的切pitch
	
	平移寫完了
	接下來resource要怎麼拿，音效怎麼出來，都還不知道
	
	找出來要怎麼讀取beatmap
	
	有另一個東西視storage，config是從那已面讀出來的
	
	storage是ㄧ個存檔案的路徑，你要什麼東西就再從storage去找出來，然後再get stream來讀
	
	beatmap manager的beatmap資料都存在資料庫BeatmapStore裡，他直接從資料庫抓就有了，所以不用import，除非去按import或下載
	
	按下setting 的import from stable時就會呼叫import工作
	
10/24
	先改成 sm用就的讀取工具，其他資源像是音樂再用薪的讀取工具
	osu裡面如果檔案沒有壓縮，beatmap manager就完全不會用到storage，會直接去固定的資料夾抓檔案。storage有get stream功能，但是他本來的file reader就已經能get stream了
	壓縮檔要用storage來讀只是因為壓縮檔讀取器只能輸入stream，他就直接用storage的get steam來丟進讀取器。
	
	寫storage寫到一半
	
	storage寫完了，再來繼續看osu怎麼串起來
	
	import部分大概寫完了
	
	再osu的son select裡面，選則歌曲是由beatmap panel的child來做，他把選則歌曲的method delegate給這個child，當這個child被點擊的時候，就會去呼叫
	選則歌曲的method，所以關於選擇的過程他完全不需要知道，只要丟給這個child，這個child收到輸入OnClick就會去呼叫song select的on select，然後就會進入
	遊戲
	
	beatmap manager也會讀取在beatmap courasel裡面，所以呈現有哪些歌曲、加入、選則歌曲都是用這個東西
	
	我寫成sheetmusic select panel，讓藍芽給command
	
10/25
	smSelectPanel->StartRequest = bind(&SongSelect::onSelected, this);
	這邊會出問題，有沒有可能bind上去的是base function 不是override?
	經過實驗，不管有沒有Static_cast，bind上去的都會是override，不會是base
	如果一定要用base，可以用lambda式，例如:
	function<int(void)> func = [pointer]() {return pointer->base::VirtualFunction(); };
	但如果想用override，一樣可以用lamda式:
	function<int(void)> func = [pointer]() {return pointer->VirtualFunction(); }; //把base::拿掉就會變會override
	
	現在有個問題，就是控制時間要跳去某小節的功能要由誰來執行，目前的架構式
	
	player
	|-time controller
	  |-empty container
		|-ruleset executor
		  |-ruleset input manager
			|-playfield
			
	其中，ruleset executor再load的時候，會去讀取sm然後把裡面的event轉換成processor，轉換這個動作是ruleset executor的工作。轉好以後丟進去playfield裡面
	
	這樣的話，可以在time controller以上的別的位置，放一個讀取sm的event的東西，讀完以後由他來告訴time controller每個小節是什麼時候，或著是直接控制time controller
	不過這個先不用寫
	
	好像插不多寫完了？
	resource store存音樂的還沒寫好
	
	C2512說沒有適當的預設建構函式，好像如果要用template constraint的話，class都要有一個無輸入的建構式，但是那個是拿來檢查template constraint，不會真的執行
	
	osu的整套resource store裡面，只有一個DllResourceStore存了路徑，其他的子store加入主store以後，要去get stream的時候都會搜尋所有store的路徑，最後就會找到這個store，然後從這個Store下面把檔案抓出來
	這個做法要用C#的assembly才能做到，如果想要用C++寫的話可以考慮https://blogs.msdn.microsoft.com/calvin_hsia/2013/12/05/use-reflection-from-native-c-code-to-run-managed-code/
	
10/26
	把資源檔嵌入程式中的做法，對vs來說很容易做到，但是在linux就很麻煩，就先把檔案轉成.o，compile的時候再compile再一起，最後轉檔的時候右要把檔案讀回來原本的形式
	非常的不順暢
	
	https://stackoverflow.com/questions/4864866/c-c-with-gcc-statically-add-resource-files-to-executable-library
	最後一個答案有一套工具可以用，不過還是很麻煩
	
	以後再用objcpy來修，現在先用storage的方法
	
	其實resource store裡面都track都是beatmap manager從Storage抓的，不是內嵌的
	sample mnager就都是內嵌的，可能要做一個假的resource store假裝是內建的
	
	resource store暫時用storage來假裝
	
	接下來要再寫一個假的DB，用CSV來代替，然後放進database store裡面
	
10/29
	把database系統寫完了，ruleset store是從檔案讀到ruleset的名稱，然後用名稱來直接聲成一個object，再把這個ruleset提取出ruleset info放進database裡
	就知道有哪些ruleset了。我可以擺個文件放ruleset資料，然後用ruleset store去讀取，就可以知道有哪些ruleset了
	
	sminfo儲存資料，完遊戲的時候再到指定路徑去抓資料，這個還沒寫
	寫好讀音樂檔怎麼讀，但是Sample怎麼讀還沒寫
	
	在instrument load on completed的時候就會把sample全都載入進去了
	目前為止track sample manager都沒問題
	
	大部分組件都完成了，現在要讓他跑起來
	
10/30
	template constraint有嚴重問題，如果他的constraint class 是virtual class，就不能檢查，匯無法Compile
	
10/31
	meteo gmae base, bindable, meteo device沒寫
	
	smmanager要寫建構子
	ruleset store...還沒寫

11/1
	database context的ruleset 現在是每次開遊戲時重新仔入，然後寫入DB，應該要改成依率從DB讀
	
	之後要把整個讀sm的流程全都順完
	
11/4 
	把讀音樂和規則寫死的地方在 player::load和SheetmusicSelectPanel::load
	
	sminfo有用到的東西只有sm decoder version、smname、sm set info的path
	真正執行的時候有用到的只有filename
	
	開始研究linux spi driver
	用file ops來控制spi
	https://www.itread01.com/content/1549810669.html
	https://forum.rocketboards.org/t/implement-a-custom-spi-device-driver/576  這個人寫不出來
	
	簡單的範例 https://stackoverflow.com/questions/22632713/how-to-write-a-simple-linux-device-driver
	
11/5
	mcp300x compile和overlay
	http://simple-is-beauty.blogspot.com/2018/11/device-tree-overlayindustrial-io.html
	
	範例少做一個sudo chmod 666 /dev/ex3，難怪都讀不到檔
	sudo chmod 666 /dev/ex3

	hrtimer範例 https://blog.xuite.net/yang44/dd/113338802-linux+timer%E6%A9%9F%E5%88%B6
	
11/8
	改device tree spi mode
	https://www.at91.com/viewtopic.php?t=21613
	spi-cpha=<1>;
	spi-cpol=<1>;
	
	dtc -O dtb -o xxx.dtb xxx.dts
	 dtc -I fs /proc/device-tree
	
11/11
	register_chrdev出來會出現在/PROC/devices裡
	class_create會在/sys/class裡面出現你命名的資料夾
	
	自己insmod的話會預設權限是root，特別的改權限方法是devnode
	https://stackoverflow.com/questions/11846594/how-can-i-programmatically-set-permissions-on-my-char-device
	
	
	dmesg -wH
	
	hrtimer速度低於10ms又用spi的話就會當掉
	一次spi大約花60us
	結論是spi太慢了，不如用bitbang
	http://ruten-proteus.blogspot.com/2012/11/io-74hc595-ic.html
	
11/12
	BCM2835裡的<stdint.h>要改<linux/types.h>，<stdlib>改<linux/string.h>
	
	driver link lib的方法 https://stackoverflow.com/questions/25856984/linking-custom-library-to-linux-kernel-module-in-the-makefile
	
	用bcm2835來做bitbang，每8bit只要4us，比Spi快很多
	
	暫時放棄寫driver，直接用user space driver
	來看一下scheduler
	
	繼續Compile
	
11/15
	找到為什麼constructor呼叫pure virtual function會undefined reference的原因了，
	https://www.artima.com/cppsource/nevercall.html
	c++不支援constructor呼叫pure virtual function(virtual function也不行)
	
	只能用Lazy Construct了，跟lazy construct做區別，這種稱為Initialize
	
	找步道libbass的方法
	https://forum.openframeworks.cc/t/use-a-dynamic-library-with-of/26031/2
	
	好像是新版的os不能用bass，舊的os就可以
	
	MeteoDisplayDevice裡面建thread會當掉，先拿掉，不知道原因
	應該是出在host 的draw frame，map會當掉
	
	把host裡面好幾行都拿掉，結果還是會卡在 draw frame那邊
	
11/17
	spi thread沒有問題
	
	callbackKeys.push_back(make_pair((uintptr_t)callableObject, callbackName)); 這行壞了
	
11/18
	draw thread會出問題
	
	matchedDisplayDevice不見了
	
	clock->ProcessFrame();有問題
	
11/19
	select panel找不到歌
	
11/20
	player::load出錯
	
	ResourceStoreWorkingSm的功能先暫時不用，因為resource store還沒開始用，storage和database都還沒寫，所以先不用
	
	讀完以後current time會出錯
	
	不知為何，runcwork一圈以後Clock會變成not started
	
11/22
	出錯的不是thread的clock，是time controoler的
	
11/23
	是time controleer的GetClock()->GetElapsedFrameTime()出錯，get clock不存在，是因為沒有重新compile
	
	還沒解決，又在更之前的create decoupled clocks出錯，是因為沒有重新compile就出錯
	
	找到問題了，decoupled clock的Source是null
	
	問題是出在，Player::load -> DecoupledInterpolatingFramedClock::ChangeSource -> DecoupledInterpolatingFramedClock::GetCurrentTime -> InterpolatingFramedClock::GetCurrentTime
	-> framedSource->GetCurrentTime，這邊的framed source是nullptr
	把null狀態直接回傳0就解決了
	
	offsetClock的source的時間是錯的，這個source就是decoupled clock
	
	出錯的地方是 InterpolatingFramedClock::ProcessFrame() -> framedSource->ProcessFrame() -> FramedClock::ProcessFrame() -> Track::GetCurrentTime()
	
	track沒有Start，start的位置是InterpolatingFramedClock::ProcessFrame的最下面
	
	determine if decoupled clock start. coupled = [1], source running = [0] 這邊coupled不可能是1
	
	找到問題，一開始要reset track寫錯寫成reset decoupled clock，音樂可以播放了，但是還是有clock時間不對
	
11/24
	在gamebase的設定beatmap change的function是add to audio manager
	
11/26
	找到問題了，basstrack的pendingActions一直沒有削掉
	
	還在研究為什麼rate會變成奇怪的值，還有decoupled clock會new兩次
	
11/28
	跑起來了，現在來看input thread。
	
	main thread: gamehost.run => gamehost.ResetInputHandlers => panel.Add InputHandler to OnPanelEvent
	
	input thread: PanelDevice.ScanInput => PanelDevice.PassToPeripheral => Panel.TriggerOnInput => PanelInputHandler.HandleState => PanelInputHandler.Pushback(states)
	
	update thread: InputManager.Update => InputManager.GetPendingState => InputManager.GetPanelInputHandler(from host) => PanelInputHandler.GetPendingStates => InputManager.Pushback(penddingStates) => InputManager.HandleNewState
					=> InputManager.UpdatePanelEvent =>
	
	中間會有memory leak，因為每次input state都是用複製的傳給對方
	
	key binding input manager那邊bluetooth的handle new state先不寫，還不知道要怎麼map過去
	
	PanelInputHandler::HandleState這個寒士會把從device來的state給clone一遍，所以device就可以把State刪掉
	
11/29 
	unput thread沒有問題，應該是update thread的問題
	改完以後一開就當機
	
12/4
	pause以後update thread會整個停掉
	
	做額外的partition 
	https://mike632t.wordpress.com/2014/02/10/resizing-partitions/
	
	安裝gcc 6.3
	https://blog.gtwang.org/programming/raspberry-pi-raspbian-compile-and-install-gcc-6/
	
12/6
	在bass上安裝
	https://github.com/cpicanco/stimulus_control/wiki/How-to-install-the-bass-library-on-linux%3F
	
	結果bass藥用hardfp才能夠跑
	
	要去raspi-config開i2c，才能用pi2c
	
	程式差不多寫完了，接下來要把map shifter從playfield移到player去
	
12/12
	找os version的方法
	cat /etc/rpi-issue
	https://raspberrypi.stackexchange.com/questions/6974/how-can-i-determine-which-os-image-i-am-running
	
	實驗發現timer list延遲很嚴重，大概4ms，hrtimer在每秒100次以上就會當機，interrupt的話延遲大約7~13us 
	gpio做一輪48個shift要70us~100us
	
	driver差不多寫好了
	
12/14
	osu的擊中判定：
	DrawableNote.OnPressed =>
		DrawableHitObject.UpdateJudgement =>
			DrawableNote.CheckForJudgement => (這邊決定有沒有擊中)
				DrawableHitObject.AddJudgement =>
					DrawableHitObject.OnJudgement =>
						Playfield.OnJudgement =>
							new Explosion #
						ScorePorcessor.AddJudgement
	
	家explosion在meteor playfield裡面的on judgement裡
	
12/15
	在城市一開始就輸入的話，就會當機，可以用keyboard模擬
	
	刪除dynamic的時候會出錯
	
12/16
	寫萬explosion，但是效果不好
	要寫放開的時候逐漸Fadeout
	
12/17
	shift寫好了，接下來應該要寫踏板和fadeout，計分，調整速度，上傳，自動彈出鋼琴音
	
	sm會亂讀檔
	
	更改速度
	http://bass.radio42.com/help/html/90d034c4-b426-7f7c-4f32-28210a5e6bfb.htm
	http://www.un4seen.com/forum/?topic=2181.0
	
	速度的公式是，如果速度變一半，音高就會降8度，八度的BASS_ATTRIB_TEMPO_PITCH要加12.f
	每升一個半音，頻綠增加1.0594630943593 (1.0594630943592953098) (1.05946309435929530984310531494)
	用1.0594630943592953098就好，精度更高電腦算出來結果也依樣
	降音是0.943874312681693417026451697893，就是1/1.0594630943592953098
	
	1 : 1.0594630943592953098
	
	換算公式：更改速度p => 更改音高ln(p)/ln(1.059)
	
	速度寫完，接下來來寫fade out
	
	還有繞圈要寫
	
	
12/19
	改的方向：先把main interface家道decpendency cache裡面，然後在base裡面去new一個output manager，百在audio manager旁邊，然後在load的時候再去把output manger和main interface接起來。
	
	output manager用法基本跟audio manager依樣?可能要設計一套output handler機制，例如panel、bt來跟output manager註冊add on event，
	output manager收到event就會叫panel、bt的function pointer，就變成panel、bt把這個事情收去做，例如再panel裡面加一個handle output，然後註冊到output manager上(用add on event...)
	panel拿到Event以後，再dynamic cast看看這個event是不是panel event，是的話再處理，不是就跳過
	
	之後只要一丟output給output manager，就會直接call到panel的handle output，變成panel處理
	
12/26

	正在寫sustain pedal ring的東西
	
	接下來要寫註冊到io communicator的方法，還有event對應到processor的方法
	
12/29
	還要寫pedal hit object，先不要寫好了
	
12/31
	每次都要先 sudo modprobe i2c-dev
	
1/4 
	踏板和fadeout，計分，調整速度，上傳，自動彈出鋼琴音，arduino讀琴鍵，修改光圈跑法
	
1/5
	firmware
	https://stackoverflow.com/questions/28398689/is-there-a-way-to-find-out-the-exact-source-tree-for-specific-raspberry-pi-kerne
	
	https://www.raspberrypi.org/forums/viewtopic.php?t=57401
	
	FIRMWARE_HASH=$(zgrep "* firmware as of" /usr/share/doc/raspberrypi-bootloader/changelog.Debian.gz | head -1 | awk '{ print $5 }')

	# get git hash for this kernel
	KERNEL_HASH=$(wget https://raw.github.com/raspberrypi/firmware/$FIRMWARE_HASH/extra/git_hash -O -)

	# Then replace the git checkout command by this one:
	git checkout $KERNEL_HASH
	
	https://www.raspberrypi.org/documentation/linux/kernel/building.md
	make oldconfig(用這個應該就不會有板子相容問題?)
	make -j4 zImage modules dtbs
	sudo make modules_install
	
	ln
	https://www.raspberrypi.org/forums/viewtopic.php?t=180743
	
	sudo dmesg -c
	sudo insmod btn_led_autoclock.ko
	sudo mknod /dev/meteo_lightboard_v1 c 201 0
	sudo chmod 666 /dev/meteo_lightboard_v1
	
1/6
	正在修播放音樂時設定音量功能
	
1/9
	音量衰減公式: http://163.13.111.54/general_physics/week-03_day-1__oscillations_SHO_damping_n_resonance.html
	
	公式: 音量=Xm*e(-bt/2m)，Xm是初始振福，b是阻尼常數，m是重量常數，t是時間，簡化後:音量=e(-at)，a為常數，t為時間
	比較後發現a設為1時誤差最小
	
	本來是考慮去比較同一個鍵上一個琴音和這一個琴音的大小，然後作替換，但是發現琴音重複彈奏的時候應該會疊加

	
	bass的sample load會直接把整個音檔都讀進去，如果100個音檔一個1M，這樣就直接吃掉記憶體100M(全都會轉wav)
	如果即時的load sample的話，會有6ms延遲，聽起來會很明顯
	如果改用streaming的話，延遲是4ms，還是太大
	應該要有一個sample pool
	
	結果只要一個sample，放很多個channel就好。
	BASS_SAMPLE_OVER根本就沒有用，到底是擺來幹嘛的？
	
	要寫一個裡面有circular list擺一串sample channel的MultiPlaybackBassSampleChannel，用來處理重複按同一個鍵的狀況
	用channelStop就會把那個channel釋放掉，就不用怕memory leak了
	
	如果用Play會直接把這個channel重播，所以不用特別暫停。
	
1/10
	音量的東西寫完了，之後可以把琴鍵和音量接起來
	後面開發的東西可能比較不急
	
	pcm5102 
	https://blog.himbeer.me/2018/12/27/how-to-connect-a-pcm5102-i2s-dac-to-your-raspberry-pi/
	
	每次都要先 sudo modprobe i2c-dev
	
1/14
	要做的事：1. 琴鍵有聲音--------------
				2. ios app
				3. 遊戲畫面
				4. 紅外線控制arduino-----
				5. 樂理遊戲畫面
				6. 寫完光圈
				7. 裝pcm5102介面xxxxxxxxxx\
				
	目前要計算壓琴鍵壓力，按琴鍵的速度是用壓下時間花多少ms來算，通常是1~100之間，我要用指數轉換成1~256，關係算式是x^256 = 100(最大音量100轉換到256) => x = 1.018151722
	最後要用壓下時間轉換到音量要用log(1.018151722)(time) = ln(time) / ln(1.018151722) = ln(time) / 0.01798894632
	
	算錯，應該是1.057018041^壓下時間才是最後音量
	
1/17
	pcm5012
	https://www.raspberrypi.org/forums/viewtopic.php?t=198708
	1 = SCK = N.C.
	2 = BCK = J8-12 = gpio18
	3 = DIN = J8-35 = gpio19
	4 = LCK = J8-40 = gpio21
	5 = GND = for instance J8-06
	6 = VIN = 5volt = for instance J8-02 or J8-04
	
	
1/20
	arudino的ir花費時間100us左右
	
	要做的事：1. 寫算分數(!)
				2. 樂理遊戲畫面
				3. ios app
				4. 遊戲畫面(!)
				5. 紅外線控制arduino
				6. 做耳機、紅外線的外殼(ok)
				7. 琴鍵聲音比音樂大
				8. 寫完光圈
				9. 找人寫拍照轉檔的app
	
1/22
	寫算分數
	
1/23
	算百分比的方法，應該適用譜面讀取器去抓hud overlay，告訴他總分，然後玩遊戲時score processor只給分數，hud display自己算百分比
	
1/29
	每次都要先 sudo modprobe i2c-dev
	
2/1
	找到不能只差i2s到主板的問題，地6pin gnd一定要插著他才會動
	
	要做的事：1. 寫算分數(!)
				2. 樂理遊戲畫面
				3. ios app
				4. 遊戲畫面(!)(改成ipad解析度)
				5. 紅外線控制arduino
				6. 做耳機、紅外線的外殼(ok)
				7. 琴鍵聲音比音樂大
				8. 寫完光圈
				9. 找人寫拍照轉檔的app
				10.輸出高品質鋼琴音
				11.
				
2/16
	在寫橫移
	
2/26
	琴鍵敏感度改成256開三百根，用按壓秒數乘3，再用底數去次方
	爆破的效果太突兀，直接拿掉。
	
2/29
	等錄完影要開始寫mode，簡單版、自動踏板...等
	自動踏板要想辦法讓計分不會亂掉
	
	meteor score processor現在會把pedal和octave事件扣掉，是暫時的寫法
	之後要先檢查是不是game control pedal，是的話再扣掉pedal hit object
	
	MeteoPianoPitchState和PianoPitchState重複了，要再修
	後來把PianoPitchState改成PianoPitchMovement，就滿合理
	
3/2
	每次都要先 sudo modprobe i2c-dev
	
	visible time range應該是在meteor playfield裡面的東西，不應該擺在event processor master裡面
	meteor event processor master應該要把period map重新建立一次，把原本的山掉，然後把visible time range加進去
	
	
3/4
	meteo game base裡面的workingSm.AddOnValueChanged 常常在遊戲開始的時候一要讀音樂就crash
	是在working sm裡面的get track理，getPathForFile那一行會出問題
	當機的地方是在 track = new RateSettableBassTrack(temp);
	https://bbs.csdn.net/topics/390963902
	
	應該就是這行出錯
	volume->AddOnValueChanged(this, bind(&AdjustableAudioComponent::OnStateChange, this), "AdjustableAudioComponent::OnStateChange");
	
	這個bug要解的話要去改bindable，整個要重compile，今天沒空先不弄
	
	耳機有噪音 要加audio_pwm_mode=2
	https://raspberrypi.stackexchange.com/questions/64450/white-noise-through-audio-jack
	問題還是沒解決
	
3/5
	在升降key的時候，score processor沒辦法正確判定，因為score processor是在event processor master裡面
	Event processor master裡面的pitch state沒有人去控制，現在只有playfield的pitch state有人控制，playfield和event processor master是兩個不同的東西

	錄音的時候gain在-8.27，shure麥克風用0db
	
	有的時候左右平移會出錯的原因，應該是因為octave shifter會叫 clock->GetFramesPerSecond，當下那個frame剛好很慢，平移就會跟著變很慢
	解決辦法是改叫average frame per second，比較不會有誤差
	好像不是這個問題，通常shifter會拿平移秒數，不會拿fps
	
3/23

4/12
	bluetooth sdp執行會出錯 segment fault
	https://raspberrypi.stackexchange.com/questions/41776/failed-to-connect-to-sdp-server-on-ffffff000000-no-such-file-or-directory
	要把bluetoothd改成compat
	每次開機都要sudo chmod 777 /var/run/sdp
	
	然後要打開藍芽配對
	sudo systemctl start hciuart
	sudo bluetoothctl
	discoverable on
	pairable on
	
	這樣可以讓手機跟bluetoothctl配對，但是部會讓advertise程式跟手機配對
	用automatic connect的話，要用
	sudo systemctl start hciuart
	sudo bluetoothctl
	discoverable on
	pairable on
	exit
	然後才能連線
	
	實驗發現只要開pairable就可以連，不用開discoverable
	
4/13
	之前訊息傳不出去，是因為用藍芽的時候不能叫sleep()，會直接停掉
	
4/18
	把平移的速度改成即時用fps反推，避免平移速度出錯
	
5/6
	sdp只是用uuid幫忙拿到channel號碼，後面的動作就是rfcomm
	
	obex server的執行方式是不停handle input，input有芬in和out，各自都有tx和rx狀態，感覺命名比較亂
	http request比較清楚，就是request出去，回來一個status code，不過如果是下載檔案，或是回傳大量資訊的話，要再看一下是怎麼寫的
	
	找不到http下載的流程
	
5/7
	api request的實作在web request裡面，api request管時間，負責備呼叫，還有開始結束失敗的callback。web request才是真正跟http丟資料的人
	http格式比較大的話，可以考慮用mqtt
	
	web request在丟出http以後，會根據get或post，開始接response，從responseStream把資料讀出來，完成以後要拿資料的話就用ResponseData把資料拿出來
	
5/11
	每次都要先 sudo modprobe i2c-dev
	
	錄音要把bose先按到最大 在暗小20次 音量降8db 麥克風屁股要禿初箱子一點
	
5/30
	在新電腦上，要用openobex要先apt-get install bluetooth、apt-get install libbluetooth-dev、apt-get install libopenobex-dev
	compile以後，多試幾次 sudo ./test就可以成功。server要先下sudo hciconfig hci0 piscan指令
	關掉wifi方法是config.txt裡dtoverlay=disable-wifi
	
	關wifi時傳1.63m的檔案要5:44，把log全關掉的狀態是1:10，也就是23kbps
	
	linux下控制網路連線的程式
	https://stackoverflow.com/questions/8661474/which-c-c-library-can-be-used-for-handling-wifi-connections-for-linux
	
	https://cgit.freedesktop.org/NetworkManager/NetworkManager/tree/examples/C/glib/add-connection-libnm.c
	
6/1
	midi to csv
	https://www.fourmilab.ch/webtools/midicsv/
	
	時間轉換方法:
	第一行的最後一個是pulse per quarter(每個四分音符幾個訊號)
	0	0	 Header	1	17	480
	然後tempo是每個四分音符多少microsecond
	1	0	 Tempo	750000
	看這兩行，把每個音的time code / 480(每個四分音符幾個訊號) * 750000(每個四分音符多少microsecond) / 1000000(以秒為單位)
	就可以算出秒數
	
	另外踏板的代號是110

6/15
	可以把一個音分成AB段，前五秒是A段，5秒後fadeout，然後B段Fade IN，一直loop就可以一直維持那個音色
	B段做一次這個音的波形就可以，中央C的波形是168個取樣點(44100)
	B段要分幾次fade out，第一次fade out較快，第二次fade out較慢，會比較真。總延音時間超過20秒效果應該會剛好
	
	BASS_SetEAXParameters應該可以用來做出琴身的共鳴感
	
6/18
	目前改玩了multiplayback有多個track的功能，正在寫鋼琴切成AB段的sample channel
	卡在overlap的地方要怎麼fadeout，秒數部會算
	
6/19
	連藍芽要用sdp的advertise才能跟手機的auto connection連線
	然後依樣改 --compat
	https://raspberrypi.stackexchange.com/questions/41776/failed-to-connect-to-sdp-server-on-ffffff000000-no-such-file-or-directory
	sudo chmod 777 /var/run/sdp
	sudo systemctl start hciuart
	sudo bluetoothctl
	discoverable on
	pairable on
	exit
	
	結束以後才能夠連線成功。如果用單純的rfcomm-server，手機會認為你的藍芽是off的狀態，一定要用sdp，在other裡面的advertise.c可以用
	
	其實只要兩個指令就夠了
	sudo chmod 777 /var/run/sdp
	sudo hciconfig hci0 piscan
	
6/20
	目前看起來bass的slide應該是10ms調整一次
	要在所有audio clomponent裡面拿到audio thread的clock，這樣sample才能算時間
	繼續寫instrument channel
	之後要在meteopiano那邊去設定音的cut time、fade out time
	
	寫到instrument channel的update
	
6/21
	把切成AB段的sample寫完了，但是現在不確定unique lock能不能在同一個函式內連續使用。測試完發現可以
	
	接下來要寫modifier、反覆練彈、storage、樂理遊戲模式、藍芽裝置、藍芽handler
	
6/22
	modifier修改遊戲的地方在ruleset container裡面修改難度，player裡面修改速度，在ruleset container的apply mods裡面修改ruleset container(例如增減column數、將落下方式由linear改為gravity)
	
	mod都是在載入的時候改一次設定，之後就不會再去call他
	mod有:
	1. 難度、左右手，去改control point
	2. 速度，去改time controller
	3. 反覆練彈，去改time controller和pattern generaotr或sm converter(換使用者彈的時候改為由下往上的特效)
	4. 
	
	另外歌曲本身應該就要可以改:
	1. 落下速度
	2. 是否有原曲
	3. 
	
	反覆練彈的部分，應該要把playfield裡面event processor master的get graph拿出來變成一個物件graph drawer，這個map drawer隨時讓time controller調整要顯示向上的燈光還是向下的燈光
	總結，反覆練彈: sm converter同時生成向下和向上的effect -> 放入專用的timer controller -> 在event processor master放入專用的 graph drawer，隨時控制要畫向上還是向下的燈光
	
	pi藍芽讀一次資料要38~20us，寫一次資料要28~17us
	
	---藍芽規劃
		
	手機->裝置

	寫入、讀取

	須回傳收到


	識別->手機版本、使用者身分、電子琴韌體版本、電子琴任體名稱、電子琴硬體資料、電子琴身分

	系統->重新啟動主板、重新啟動子板、重新啟動aPP

	心跳->心跳、斷線、重連

	基本功能->音量調整、延音開關、力度開關

	場景->選單、遊戲準備、遊戲、遊戲結束、重播、互動、錄製、擴充升級

	log->讀取log、更改log等級、刪除log、儲存log、開啟即時傳遞、即時傳遞log

	紀錄->讀取電子琴紀錄

	設定->寫入設定、讀取設定

	遊戲準備->調整遊戲設定、下載譜檔、開始載入遊戲、載入遊戲完成

	遊戲-> 1.一般遊戲-對時、更改時間、更改速度、按下、放開、得分、暫停、繼續
		   2.反覆練彈-更改狀態、練習次數、更改小節

	遊戲結束->傳送總分、傳送重播譜檔

	重播->下載譜檔、開始載入遊戲、載入遊戲完成

	互動->互動開始、互動結束、按下、放開、顯示燈光、燈光事件、音效事件

	錄製->開始錄製、按下、放開、結束錄製、傳送譜檔

	擴充升級->下載音色、下載主程式
	
	
6/23
	藍芽rfcomm和l2cap的默認mtu是672bytes
	
6/29
	beatmap difficulty目前看起來不太重要，他是定義osu的圓圈大小，縮緊速度，滑動時獲得多少分數。我們的設計裡面比較沒有這類東西，所以可以空著不用
	所以modifier也不需要去修改難度
	
	反覆練彈應該適用把get event processor替換成專用的get event processor(策略模式)，裡面會把每一個fall effect都同時放一個erupt effect。
	然後再把time controller替換成會自動倒退的time controller，並且去控制event processor master這一次要顯示fall effect還是erupt effect
	score processor再看要怎麼改
	
	time controller應該不要動，改成sm converter自動在每個小節生成小節分隔，然後effect去抓這個分隔，轉出倒退event。
	倒退event每次發生就在裡面+1，加到4就歸零並且跳到下一個小節。event processor master要控制當下只能播放該小節的Event，不然會播到其他小節的event
	
	另外Evnt processor master也要可以控制要播放左手/右手、簡單困難。
	
	要在event processor master裡面的GetItemsContainPeriods，預先設定哪些effect會被它拿出來，哪些不用拿出來
	所以要在裡面差一個判斷函式，要在period裡面放一個fliter，這個filter要去讓遊戲設定抓到，才能讓modifier能夠從filter去挑選出自己要用的event processor，去掉不要的
	
	instrument controller、playfield controller是在meteor playfield的load裡面載入的，event processor master是在playfield裡面載入的
	應該是在ruleset executor裡面建立filter，然後modifier在ruleset executor load的時候加入filt函式，
	
	filter不該寫在period map裡面，要寫在外面，所以總共要寫在MeteorEventProcessorMaster::update、EventProcessorMaster::processEvent、EventProcessorMaster::GetGraph三個地方
	而且get graph是draw thread，其他是update thread，所以要小心衝突
	
	filter寫好了，接下來應該要寫modifier怎麼套進去
	
7/3
	meteor ruleset executor要在create time controller時，創一個可以收集每一小節位置的time controller，這樣轉小節旋鈕的時候才可以轉到正確位置
	然後meteor ruleset executor要把讀出來的譜整個檢查一遍他的小節位置，再把小節位置丟給meteor time controller
	之後反覆練彈就統一由meteor time controller來做反覆，所以反覆練彈的event processor controller要去抓time controller
	
	time controller的event processor controller要在playfield裡面加入
	
	目前改成meteor ruleset executor會再load的時候把每個小節秒數丟進meteor time controller裡，注意之後要記得回去把decoder出來的event重新排序一次，不然會出錯
	
	現在看起來應該是meteor time controller要去控制filter，然後repeat event去控制meteor time controller，event不用直接控制filter。
	
	
	要再做一個repeat event，負責控制time controller
	
	現在不知道左右手、困難度那些要不要做enum。目前寫到meteor time controller
	
7/4
	左右手、困難度用apply mod加到filter裡面就好，
	
	beatmap裡面本來就有設計difficulty功能，我們應該把困難度、左右手、落下速度什麼的擺在difficulty裡面，之後再用apply to difficulty去修改就好。
	然後發現beatmap還有個欄位叫event，octave shift應該要擺在那個欄位才對
	
	發現我應該寫錯了，pattern generator不需要這麼早生成，是因為pattern generator只要讀beatmap裡面的各項設定，就能生成燈光
	beatmap會記錄各種設定，紀錄方式是用applymod去把要改的東西放進去，所以其實只要把要改的東西丟進去beatmap就好，不用碰到pattern generator
	先做好beatmap difficulty就好，pattern generator以後有空再修
	
	
7/6
	寫道要把repeat practice controller家道meteor playfield李
	
7/7
	目前寫到把反覆練彈家到Meteor time controoler裡面，還沒寫怎麼樣控制filter
	再寫filter
	
	filter寫到一半，先寫erupt effect，都寫完以後要開始改modifier
	
	改了設計 difficulty modifier以後只用來調整分數，converter會把所有processor都生出來，我們再自己用filter去篩，modifier可以去調整filter
	
	然後落下速度改為使用modifier對每一個event修正，這邊寫到一半
	
7/8
	目前寫到把所有event都根據modifier去做修改，有的修改落下速度(fall effect)，有的修改得分(hit object)，部過從sm difficulty轉換成hit window那邊還沒寫
	接下來要寫converter做出倒轉事件、上升特效事件
	
	倒轉事件做完了，接下來要把每個modifier都寫
	
7/9
	modifire改玩了，部過要把decoder 裡面加上可以去讀這個埔有沒有hand section difficulty speed這些資訊
	Score processor比較不急，先不改
	要找時間研究一下在遊戲開始之前就可以彈出聲音(以後要寫換音色)
	
	看起來是ok，遊戲還沒開始就會可以談音樂，換音色在load and map samples那邊，應該很好改
	
7/10
	osu beatmap的一些參數介紹
	https://firce777.wixsite.com/taiko-mapping/1-2
	
	改好decoder了，以後要再general裡面加兩行
	Mode:1
	Section:1
	HandType:3
	[Difficulty]
	Speed:16
	
	decoder都改完了，接下來最大的鏗是storage，裡面有資料庫，看看要怎麼寫
	
	當出現Please specify which branch you want to merge with.的解決辦法
	git branch --set-upstream-to=origin/RepeatPracticeModifier RepeatPracticeModifier
	
	ruleset executor - playfield - add on judgement那邊友bug
	
7/11
	music game mode成功跑起來了，repeat practice先不管
	
7/12
	database分兩種，一種是readonly的csv假DB，一種是memory做的假DB，一關機就會消失，所以不能真的存資料
	
	找到osu加beatmap進db的方法 ImportFromStable -> Import(stable.GetDirectories("Songs")); ->  Import(reader); -> var iBeatmaps = createBeatmapStore(() => context); 
	
	下載後加入db有兩個方法: BeatmapManager::Download 和 OsuGameDesktop::fileDrop
	
	song select拿到beatmap資料的方法是 carousel.Beatmaps = this.beatmaps.GetAllUsableBeatmapSets();
	
	panel裡面每個sm都要有一個workingsm
	
	MeteoGame在load on complete的時候會先把sm給import from stable，讀完所有sm才會開始進入loader，開始push scene，所以song select拿到的sm infos是固定的
	如果變成sm manager可以下載的話，song select就必須隨時修改sm infos
	
	照osu原本的寫法，如果他在選歌畫面下載歌曲，下載完就要重新載入song select或是carousel，因為他沒有sync beatmaps的機制
	
	不過我們可以改寫這個寫法，改成sheetmusic panel在每次下載完都refresh一次，對sm manager註冊一個下載完就更新的callback，當download完畢就會呼叫
	
	現在可以先不管這個部分，先把原本內容寫好就好
	
	在最後放進ruleset executor要抓出來的時候，會在working beatmap去get beatmap，這個時候才會用decoder重新把beatmap讀一遍，拿到所有hit object。
	這個地方beatmap manager就必須先拿到beatmap set info的path，再加上beatmap info的path，才能拿到這個beatmap的位置
	
	所以我們必須同時在sm info裡面存資料夾路徑(如beatmap set info的path)和檔案名稱(如beatmap info的path)，不需要用到任何資料庫。
	
7/13
	還是有在get path for file的時候用到store，不過幾乎是沒用，只是拿它裡面有個寒士用而已
	
7/14
	osu找不太到特別的更換sample的機制，這個應該要自己寫，另外也要寫刪除舊sample的功能，不然記憶體不夠
	
	keybinding store等到作更大的琴在寫都來得及
	
	現在寫storage的部分，storage最根的只會留一個，然後在那個資料夾下建link連道別的磁碟分割
	目前麻煩的是同一批資料要來自兩個不同地方(readonly分割和可寫入分割)，要研究一下Storage是怎麼運作的
	
	鋼琴音ab段的問題解決了，直接讓B段從一開始就播放，然後到切換時間再把A段音量關掉，B段音量打開就好
	
	csv database的東西還是要寫完，不然城市不能跑，player裡面拿ruleset id的部分也要跟著換掉
	
	repeat prctice沒有轉出time controller event
	
7/15
	電子琴城市勝：storage要分兩半、藍芽、AB段音效、換音效、播譜(1)、mcu程式(2)、降低延遲(3)、下載、daemon、wifi、replay紀錄
	
	延遲時間:
	
	適用於延遲時間的一般準則 
	不到 10 毫秒 (ms) – 可即時監控傳入的音軌，包括效果。 
	10 毫秒 (ms) 時 – 可偵測到延遲，但聽起來仍自然且對監控而言仍有用。 
	11 至 20 毫秒 (ms) – 監控開始變得不實用，實際音源變得模糊，而且監控的輸出相當明顯。 
	20 至 30 毫秒 (ms) – 延遲的聲音開始聽起來像真正的延遲，而非原始訊號的一部分。 
	
	input thread速度可以到1800/s，但audio thread只有350/s，把lock拿掉也依樣慢，要看一下為什麼
	
7/16
	要寫自動播譜，但是音量不知道為什麼會變亂碼
	4 : VirtualPianoController::implementControlInstrument() : play sound [5.47] on [74] with volume [1065287680].
	另外也找不到sample對應到pitch
	
7/17
	自動播譜寫出來了，琴音如果大於0.5就會破音，之後應該直接條小virtual piano的音量
	
	解決延遲的方法就是要把播放直接寫再input manager李，不然從input->update->audio，延遲就會很嚴重
	
7/18
	突然出現的雜音是因為一個音播放到一半突然斷掉，要解決的話就要讓他fadeout
	
	最後用dual playback解決了
	
	永久關閉raspbian的虛擬記憶體(swap memory):
	https://paulcourt.co.uk/article/pi-swap
	
	sheetmusic converter裡面create other event寫錯了，temp event是空的，難怪沒有辦法生出repeat practice event
	
	按鍵按下是在input thread，按完以後會直接跳到audio thread，所以部會經過update thread，速度可以更快
	
7/20
	storage室友寫入的功能的，只要用get stream，名稱擺上路徑，就可以寫入檔案
	下載新譜檔的時候，下載器在success時會把data丟進beatmap manager的import裡，import會去檢查storage裡面有沒有這個檔案，沒有的話就會叫storage的get stream寫入這個Data
	然後名稱會從剛建立的file info裡面拿
	
	要先把我們城市裡的ifstream改成fstream，才能同時寫入和讀取
	
	replay看要寫在score processor裡還是重新寫一個replay recorder
	完全找不到osu的replay寫在哪，他應該會把replay寫入一個類似beatmap的黨哩，之後要replay時再讀
	真的沒辦法的話我們要自己寫一個replay recorder，在遊戲結束時，自動把錄到的內容寫入一個檔案中，然後再把檔案傳到手機
	
	再player的oncomplete會push result，進入分數畫面結束遊戲。on complete註冊在score processor的all judge下面，每次計算分數時都會檢查一次是不適all judged，是的話就執行all judge
	
	執行完all judge，就會進入result，按下back button就會exit to parent scene，這時因為player的Available for resume是false，所以就會回上一層，跳到song select去
	
7/25
	如果要再遊戲結束前後restart，要先把player loader設成valid for resume，然後再exit，這樣player loader就會load同一個東西
	
	再delete child的時候，為避免有其他thread正在使用那些物件，要先用thread master把所有thread都停掉，再delete child。
	
	寫到replay
	
7/28
	輸出藍芽是要物件自己去抓output manager，然後建藍芽message，丟給output manager，output manager會自己根據你丟的訊號種類，找到藍芽output manager，然後叫他把訊號丟出去
	
7/29
	在寫bt device，暫時不用寫太完整
	
7/31
	把bt的部分很多東西補起來，但是沒有補得很完整
	
8/7
	compile看看程式，compile過了，可以來寫寫看recorder。寫了紀錄，沒寫轉檔成文字，和送出藍芽

8/18
	看一下result有沒有問題
	
8/19
	result可以順利跳回song select了
	現在來寫及時模式instant
	在playfiend下面加一個DynamicEventGenerator，即時收到訊息然後轉換成事件丟進去
	
8/20
	用event processor master把按下的鍵丟出去，丟到藍芽
	
	應該要自己測試傳檔o不ok，自己寫一隻程式來測
	
	做了互動的落下和光線特效
	
	要去sheetmusic manager改收到新埔的反應，因為bt收到普不會讓琴知道，琴要自己去重新掃一遍所有普，然後把新埔加進去
	song select panel則是只能等待譜傳完以後，收到開始遊戲，才會開始。如果譜沒傳完，收到開始遊戲時不會開始。這邊要修改每次呼叫遊戲開始，都要重新掃一遍所有譜
	
8/21
	把下載譜改成每個譜都放在獨立的資料夾，然後每次下載完以後就可以用file reader讀那整個資料夾裡面的譜，就不會讀到舊的譜
	
8/24
	instant下面要再做一個piano event
	補了一些instant的東西，之後還要做ruleset info和未進入遊戲時的移調
	
8/31
	缺的東西: mcu、ruleset info(ok)、未進入遊戲的移調(ok)、琴音分為全長和AB段、琴音切換、wifi、daemon、重播存檔、OS設定、平移會lag、換上新音色、遊戲開始前倒數3秒(ok)、刪除所有memory leak
				遊戲開始前設定mod(ok)、遊戲開始時改速度(ok)、手動踏板modifier、紀錄每個modifier到藍芽架構裡、me555、測試藍芽傳送
	
9/1
	找到mcu輸出uart debug資料的方法: 在project裡面DEBUG_ENABLE_SEMIHOST=1，才能收到uart訊號
	
9/2
	找出怎麼接i2c訊號，他會一個一個char擺進g_au8SlvRxData裡面，
	目前的mcu是直接設定不看地址，所有資料都收
	pi先執行pi2c，把資料write進mcu，mcu再用中斷printf出來
	
	讀slave資料目前讀不出來
	https://www.nuvoton.com/export/resource-files/TRM_ML51_Series_EN_Rev1.02.pdf
	249頁，status先是0xa8，之後變oxb8
	在handler裡面加上這行就好，oxb8是代表說要循環取i2cdat的意思
	
    else if(u32Status == 0xB8)                  /* from datasheet to know 0xb8 is how to use TRM_ML51_Series_EN_Rev1.02.pdf */
    {

        I2C0->I2CDAT = g_au8SlvData[slave_buff_addr];
        slave_buff_addr++;
        I2C_SET_CONTROL_REG(I2C0, I2C_I2CON_SI_AA);
    }
	
	read是在0xC0結束，write沒有結束status，可能要用\0來判斷，不過在收到下一個訊號的時候會先收到0xA0(restart的意思)
	
	
	
9/3
	把mcu的i2c城市稍微寫出來
	
9/4
	不知道為什麼在mcu不能用時間韓式
	timer_perodicINT專案有計時的程式，mcu的時間要用timer來換算，沒有內建的時間函示
	用他的timer來抓ms，就可以寫程式了
	
9/5
	不知道為什麼i2c一職丟不出去list裡面的資料
	忘記給buffer的指標
	
	現在改成如果收到的第一個unsigned char是1，就是有心資料可以讀，如果是0就是沒有資料
	
	要寫一下list 的 lock
	
	i2c差不多寫出來了，不過要注意的是，mcu的i2c沒有read fail的功能，只能讀到空值，如果是空值的時候，第一個獨到的字的第一個bit會變成1，如0x0會變成0x80，可以用這個判斷mcu有沒有送資料
	
9/6
	在i2c read pi的時候，list不能用blocking，會出很多問題，所以暫時不用lock直接操作
	
	如果i2c時有printf的話就很容易當機，沒printf也會盪
	
	i2c的pi write mcu i2c status是0x60開始，傳資料是0x80，沒有結束，但是下一個開始的時候會先叫0xA0，然後才重新開始0x60、0x80...
	
	在list.c裡面 memcpy(buffer, list->head->content, sizeof(char) * CIRCULAR_LINKED_LIST_CONTENT_MAX_SIZE);的時候，size會莫名其妙+1
	https://community.arm.com/developer/tools-software/tools/f/keil-forum/31706/hard-fault-at-misaligned-memcpy-memset]
	
	把memcpy和memset全都拿掉，結果過了好幾個while迴圈還是會自動跑出來list的size+1，只能去問問看
	
9/7
	把access的on write sm success寫完了，之後要去寫下載好主程式、音檔的時候要如何移動到正確的位置。
	
	template function循環include
	https://stackoverflow.com/questions/17482316/c-circular-dependency-issue-with-function-templates
	
	circular dependency的template function會讓程式碼失去彈性，因為template必需要explicitly instantiation才能定義function，如果沒有explicitly instantiation的template就不能用
	所以要避免
	
	cns14408、cns13439
\
9/11
	結束後沒有辦法回到song select，要看一下哪堨X問題
	
9/13
	delete childscene這一行錯了，把它註解掉就沒問題了
	
	改用thread master，不過thread master沒執行，可能是沒放這條thread
	
9/15
	把delete child scene寫完了，但是working sm裡面的event有沒有清乾淨還要在確定
	
9/16
	git合併分支
	https://git-scm.com/book/zh-tw/v2/%E4%BD%BF%E7%94%A8-Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%92%8C%E5%90%88%E4%BD%B5%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95
	
	現在要先把AB段寫完，用sound binding set自動抓音檔檔名，再用instrument來切換音檔
	
	最後決定多做一個sample channel generator，吃resource store和sound binding，就可以生出Sample channel
	
9/17
	寫了SwitchSoundBindings，之後用這個來切換音色
	接下來要研究怎麼把audio component給移除掉
	
9/18
	BASS_SampleFree和BASS_ChannelStop哪個先都可以
	
	接下癌要寫用sample manager讀sound binding set，還有sound select panel切換音色
	
9/19
	要把sound binding set全改public，比較好decode
	
	decoder和switch sound都寫了，接下來要寫各種sample channel，有Repeat和ABcut
	接下來應該要先測藍芽手機連線
	
9/22
	想要測量bass audio播放音效的延遲多久，但是因為bass讀取播放秒數是每10ms更新一次，所以不太準，只知道延遲不會超過5ms
	
time after play(us):15461, real play time:9977.32
time after play(us):15510, real play time:19954.6 ->>最多延遲5ms，但是不太準

	不管怎樣就是沒辦法用手機丟訊息到pi
	
	藍芽傳輸測完，要用大台電腦的my demo才有辦法從手機丟訊號到pi
	c#的binary formatter不能用，要自己用byte的copyto功能，把struct一段一段轉成byte。不知道為什麼c#的String沒有結尾符號(\0)。所以要自己在字串結尾補一個值為10的byte
	
	藍芽app的source code在這
	https://github.com/badranX/bt-lib
	在這裡面再補上sdp的code就沒問題。部過pi那邊還要解決要用bluetooth之前要先下好指令的問題
	sudo systemctl start hciuart
	sudo bluetoothctl
	discoverable on
	pairable on
	
	只要下sudo hciconfig hciX piscan就可以，所以開機時要執行的指令有
	sudo chmod 777 /var/run/sdp
	sudo systemctl start hciuart
	sudo hciconfig hci0 piscan
	下完就可以連藍芽了
	
	新的規畫讓藍芽大小不會超過600byte，所以應該不會有同一個封包被切成兩段的問題，但是還是可能會兩個封包擠在一起
	
	
	i2c: 
	只要pi沒有read的話，記憶體通常不會亂掉
	只要interrupt裡面沒東西，mcu就不會當掉
	
	memset會亂掉，0xA8會直接當掉
	把0xA8裡面的 if(CircularLinkedList_PopHeadNonBlocking(outputBuffer, (char*)g_au8SlvSendData) > 0) 拿掉以後就不會當掉了
	
	0xB8也會亂掉
	
	重新測一次，前面測的有問題
	
	0x60 ok
	
	0x80 裡面的
		CircularLinkedList_PushBack(inputBuffer, (char*)g_au8SlvReceiveData, g_u8SlvReceiveDataLen); 有問題，一執行記憶體就會亂掉
		
	0xA8 裡面的
		if(CircularLinkedList_PopHeadNonBlocking(outputBuffer, (char*)g_au8SlvSendData) > 0) 有問題，一執行記憶體就會亂掉
		
	0xB8 ok
		
	0xC0 ok
	
	0xA0 ok
	
	所以問題都是出在CircularLinkedList上面
	
9/23
	鮮血藍芽加解碼